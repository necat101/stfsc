# STFSC Engine: "Fuck Script" Ruleset & Technical Guide

This document serves as a guide for future AI agents and developers working with the STFSC engine's scripting system.


This is where we get Intimate with the engine, hence the name "Fuck Script" :3

## 1. System Overview
"Fuck Scripts" (trait `FuckScript`) are the primary way to define dynamic entity behaviors in Rust. They are integrated into the engine's `hecs` ECS.

## 2. Core Architecture
- **Trait**: `FuckScript` defined in `src/world/scripting.rs`.
- **Methods**:
    - `on_start(&mut self, ctx: &mut ScriptContext)`: Called when the script first runs.
    - `on_update(&mut self, ctx: &mut ScriptContext)`: Called every logic frame.
    - `on_enable(&mut self, ctx: &mut ScriptContext)`: Called when the script/entity is enabled.
    - `on_disable(&mut self, ctx: &mut ScriptContext)`: Called when disabled or removed (cleanup).
    - `on_collision_start(&mut self, ctx: &mut ScriptContext, other: Entity)`: Collision begins.
    - `on_collision_end(&mut self, ctx: &mut ScriptContext, other: Entity)`: Collision ends.
    - `on_trigger_start(&mut self, ctx: &mut ScriptContext, other: Entity)`: Trigger volume overlap starts.
- **ScriptContext Helpers**:
    - `get_component<T>()`: Get a read-only ref to a component.
    - `get_component_mut<T>()`: Get a mutable ref to a component.
    - `transform()` / `transform_mut()`: Quick access to the entity's transform.
    - `despawn_self()`: Safely remove the current entity from the world.

## 3. ECS Integration
- **DynamicScript Component**: Holds the script in an `Option<Box<dyn FuckScript>>`.
- **Logic Thread**: `GameWorld::update_logic(dt)` iterates over `DynamicScript` components.
- **Safety Pattern (The Take Pattern)**:
    To allow scripts to mutably borrow the ECS world while they are being updated, we MUST use the `take()` pattern:
    1. `Option::take()` the script from the `DynamicScript` component.
    2. Call `on_update` with a `ScriptContext` that borrows the world.
    3. Put the script back into the component.
    *Failure to do this will result in borrow checker errors (E0502).*

## 4. Player Tracking
- **Player Marker**: A `Player` component exists in the ECS. 
- **Platform Sync**: The engine (in `main.rs` and `lib.rs`) automatically spawns a `Player` entity and syncs its `Transform` to the camera/headset pose every frame.
- **Accessing Player**: Use a query to find the player position in scripts:
  ```rust
  for (_e, (t, _p)) in ctx.world.query::<(&Transform, &Player)>().iter() {
      let player_pos = t.position;
      // ... logic
  }
  ```

## 5. Built-in Script Archetypes
- **TestBounce**: Simple oscillating movement.
- **CrowdAgent**: Standard NPC movement with target seeking, steering, and **Stuck Detection** (picks new target if stationary for 1.5s).
- **PoliceAgent**: Chases the player within a 30m radius using steering.
- **TrafficAI**: Vehicle AI that handles physics-based suspensions and uses raycasts (5m) to **Stop for Obstacles** or other cars.
- **WeaponNPC**: Basic combat logic that makes the entity rotate smoothly to face the player.

## 6. Registration & Deployment
- **ScriptRegistry**: Maps string names to script constructors in `GameWorld::new()`.
- **Deployment**: The editor sends `SceneUpdate::AttachScript { id, name }`. Ensure new script names are registered in `src/world/mod.rs`.

## 7. Scripting Standards
- Scripts should be `Send + Sync`.
- Avoid heavy allocations inside `on_update`.
- For movements, prefer updating the `Transform` position or applying forces to a `RigidBodyHandle` if the entity is physics-enabled.

## 9. Advanced Features (Scripting Update v2)

### Collision & Trigger Events
Scripts can now react to physics interactions.
- **`on_collision_start`**: Triggered the frame a collision begins.
- **`on_collision_end`**: Triggered the frame a collision ends.
- **Mapping**: The engine uses `RigidBody` user-data to map handles back to ECS `Entity` IDs. Ensure any manually spawned physics entities set their `user_data` to `entity.to_bits().get() as u128`.

### Component Access
Use the `ScriptContext` helpers for ergonomic ECS manipulation:
- `ctx.get_component::<T>()` -> `Option<Ref<T>>`
- `ctx.get_component_mut::<T>()` -> `Option<RefMut<T>>`
- `ctx.despawn_self()`: Deletes the entity the script is attached to.

### Lifecycle Flow
1. **`on_start`**: Initialization.
2. **`on_enable`**: Activation (can be called multiple times if toggle-able).
3. **`on_update`**: Per-frame logic.
4. **`on_disable`**: Cleanup/Deactivation (called on entity deletion or script removal).

---
*Note: Always remember to handle the 'Take Pattern' when calling functions that might re-borrow the world.*

